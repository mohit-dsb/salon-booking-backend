generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

enum Role {
  ADMIN
  MEMBER
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum ShiftStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum RecurrencePattern {
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  CUSTOM
}

model Category {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String // Original name with proper casing for display
  slug        String // URL-friendly slug for uniqueness and routing
  description String?
  orgId       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  services Service[]

  // Ensure slug is unique within each organization
  @@unique([slug, orgId])
  @@index([orgId])
}

model Service {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  slug        String // URL-friendly slug for uniqueness and routing
  description String?
  price       Float
  duration    Int // Duration in minutes
  categoryId  String   @db.ObjectId
  orgId       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  category       Category        @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  memberServices MemberService[]
  appointments   Appointment[] // Services can have many appointments

  // Ensure slug is unique within each organization
  @@unique([slug, orgId])
  @@index([categoryId])
  @@index([orgId])
}

model Member {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  clerkId          String    @unique
  orgId            String
  role             Role      @default(MEMBER)
  username         String
  email            String
  phone            String?
  profileImage     String?
  jobTitle         String?
  bio              String?
  workingHours     Json? // Store working hours as JSON
  isActive         Boolean   @default(true)
  commissionRate   Float? // Commission percentage (0-100)
  hourlyRate       Float? // Hourly rate for services
  dateOfBirth      DateTime?
  address          Json? // Store address as JSON
  emergencyContact Json? // Store emergency contact as JSON
  startDate        DateTime  @default(now())
  endDate          DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relationships
  memberServices     MemberService[]
  appointments       Appointment[] // Appointments assigned to this member
  bookedAppointments Appointment[]   @relation("BookedAppointments") // Appointments booked by this member
  cancelledAppointments Appointment[] @relation("CancelledAppointments") // Appointments cancelled by this member
  shifts             Shift[]
  createdShifts      Shift[]         @relation("CreatedShifts")

  @@unique([email, orgId])
  @@index([orgId])
}

model MemberService {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  memberId  String   @db.ObjectId
  serviceId String   @db.ObjectId
  orgId     String
  createdAt DateTime @default(now())

  // Relationships
  member  Member  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  // Ensure a member can only be assigned to a service once
  @@unique([memberId, serviceId])
  @@index([orgId])
}

model Client {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  firstName   String
  lastName    String
  email       String
  phone       String?
  dateOfBirth DateTime?
  address     Json? // Store address as JSON
  notes       String? // Internal notes about the client
  preferences Json? // Client preferences (communication, services, etc.)
  orgId       String
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relationships
  appointments Appointment[]

  // Ensure email is unique within each organization
  @@unique([email, orgId])
  @@index([orgId])
  @@index([firstName, lastName])
}

model Appointment {
  id                 String            @id @default(auto()) @map("_id") @db.ObjectId
  clientId           String?           @db.ObjectId // Optional for walk-in appointments
  memberId           String            @db.ObjectId
  serviceId          String            @db.ObjectId
  orgId              String
  status             AppointmentStatus @default(SCHEDULED)
  startTime          DateTime
  endTime            DateTime
  duration           Int // Duration in minutes (copied from service for historical accuracy)
  price              Float // Price at time of booking (copied from service for historical accuracy)
  notes              String? // Appointment-specific notes
  internalNotes      String? // Internal staff notes
  cancellationReason String? // Reason for cancellation if cancelled
  cancelledAt        DateTime?
  bookedBy           String            @db.ObjectId // Member who booked the appointment
  cancelledBy        String?           @db.ObjectId // Member who cancelled the appointment

  // Walk-in appointment fields (used when clientId is null)
  walkInClientName  String? // Temporary name for walk-in client (e.g., "Walk-in #123")
  walkInClientPhone String? // Optional phone for walk-in client

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  client         Client? @relation(fields: [clientId], references: [id], onDelete: Cascade) // Optional for walk-ins
  member         Member  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  service        Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  bookedByMember Member  @relation("BookedAppointments", fields: [bookedBy], references: [id], onDelete: Cascade)
  cancelledByMember Member? @relation("CancelledAppointments", fields: [cancelledBy], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([clientId])
  @@index([memberId])
  @@index([serviceId])
  @@index([startTime])
  @@index([status])
  @@index([bookedBy])
}

model Shift {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  memberId String @db.ObjectId
  orgId    String

  // Shift timing
  date      DateTime // The date of the shift (YYYY-MM-DD)
  startTime String // Start time in HH:MM format (e.g., "09:00")
  endTime   String // End time in HH:MM format (e.g., "17:00")
  duration  Float // Duration in hours (calculated from start/end time)

  // Shift details
  title       String? // Optional title for the shift
  description String? // Optional description
  color       String? // Hex color for calendar display (e.g., "#3B82F6")

  // Shift status
  status ShiftStatus @default(SCHEDULED)

  // Break information
  breaks Json? // Array of break periods: [{ startTime: "12:00", endTime: "13:00", title: "Lunch" }]

  // Recurring shift information
  isRecurring       Boolean            @default(false)
  recurrencePattern RecurrencePattern?
  parentShiftId     String?            @db.ObjectId // Reference to parent recurring shift

  // Metadata
  createdBy String   @db.ObjectId // Member who created the shift
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  member          Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  createdByMember Member @relation("CreatedShifts", fields: [createdBy], references: [id])

  @@unique([memberId, date, startTime]) // Prevent overlapping shifts
  @@index([orgId])
  @@index([memberId])
  @@index([date])
  @@index([status])
}
