generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

enum Role {
  ADMIN
  MEMBER
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum CancellationReason {
  NO_REASON_PROVIDED
  DUPLICATE_APPOINTMENT
  APPOINTMENT_MADE_BY_MISTAKE
  CLIENT_NOT_AVAILABLE
}

enum ShiftStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum RecurrencePattern {
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  CUSTOM
}

enum ClientGender {
  Male
  Female
  Other
}

enum ClientSource {
  WALK_IN
}

type Address {
  street      String?
  district    String?
  city        String?
  state       String?
  postcode    String?
  country     String?
  addressType String? // e.g., Home, Work
}

model Category {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String // Original name with proper casing for display
  slug        String // URL-friendly slug for uniqueness and routing
  description String?
  orgId       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  services Service[]

  // Ensure slug is unique within each organization
  @@unique([slug, orgId])
  @@index([orgId])
}

model Service {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  slug        String // URL-friendly slug for uniqueness and routing
  description String?
  price       Float
  duration    Int // Duration in minutes
  categoryId  String   @db.ObjectId
  orgId       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  category       Category        @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  memberServices MemberService[]
  appointments   Appointment[] // Services can have many appointments

  // Ensure slug is unique within each organization
  @@unique([slug, orgId])
  @@index([categoryId])
  @@index([orgId])
}

model Member {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  clerkId          String    @unique
  orgId            String
  role             Role      @default(MEMBER)
  username         String
  email            String
  phone            String?
  profileImage     String?
  jobTitle         String?
  bio              String?
  workingHours     Json? // Store working hours as JSON
  isActive         Boolean   @default(true)
  commissionRate   Float? // Commission percentage (0-100)
  hourlyRate       Float? // Hourly rate for services
  dateOfBirth      DateTime?
  address          Address?
  emergencyContact Json? // Store emergency contact as JSON
  startDate        DateTime  @default(now())
  endDate          DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relationships
  memberServices        MemberService[]
  assignedAppointments  Appointment[]   @relation("AssignedAppointments") // Appointments assigned to this member (as service provider)
  bookedAppointments    Appointment[]   @relation("BookedAppointments") // Appointments booked by this member
  cancelledAppointments Appointment[]   @relation("CancelledAppointments") // Appointments cancelled by this member
  shifts                Shift[]         @relation("AssignedShifts") // Shifts assigned to this member
  createdShifts         Shift[]         @relation("CreatedShifts")

  @@unique([email, orgId])
  @@index([orgId])
}

model MemberService {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  memberId  String   @db.ObjectId
  serviceId String   @db.ObjectId
  orgId     String
  createdAt DateTime @default(now())

  // Relationships
  member  Member  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  // Ensure a member can only be assigned to a service once
  @@unique([memberId, serviceId])
  @@index([orgId])
}

model Client {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  firstName   String
  lastName    String
  email       String
  gender      ClientGender
  phone       String?
  dateOfBirth DateTime?
  addresses   Address[]
  orgId       String
  isActive    Boolean      @default(true)

  // ADDITIONAL INFO
  clientSource      ClientSource @default(WALK_IN) // How the client heard about the business
  referredById      String?      @db.ObjectId // Which client referred this client
  preferredLanguage String? // Client's preferred language
  occupation        String? // Client's occupation
  country           String? // Client's country

  // ADDITIONAL CONTACT DETAILS
  additionalEmail String? // Secondary email address
  additionalPhone String? // Secondary phone number

  // NOTIFICATION PREFERENCES
  notifyByEmail    Boolean @default(true) // Email notifications enabled
  notifyBySMS      Boolean @default(false) // SMS notifications enabled
  notifyByWhatsapp Boolean @default(false) // WhatsApp notifications enabled

  // MARKETING PREFERENCES
  allowEmailMarketing    Boolean @default(false) // Allow email marketing
  allowSMSMarketing      Boolean @default(false) // Allow SMS marketing
  allowWhatsappMarketing Boolean @default(false) // Allow WhatsApp marketing

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  appointments Appointment[]
  referredBy   Client?       @relation("ClientReferrals", fields: [referredById], references: [id], onDelete: NoAction, onUpdate: NoAction)
  referrals    Client[]      @relation("ClientReferrals")

  // Ensure email is unique within each organization
  @@unique([email, orgId])
  @@index([orgId])
  @@index([firstName, lastName])
}

model Appointment {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  clientId            String?             @db.ObjectId // Optional for walk-in appointments
  memberId            String              @db.ObjectId
  serviceId           String              @db.ObjectId
  bookedByMemberId    String              @db.ObjectId // Member who booked the appointment
  orgId               String
  status              AppointmentStatus   @default(SCHEDULED)
  startTime           DateTime
  endTime             DateTime
  duration            Int // Duration in minutes (copied from service for historical accuracy)
  price               Float // Price at time of booking (copied from service for historical accuracy)
  notes               String? // Appointment-specific notes
  internalNotes       String? // Internal staff notes
  cancellationReason  CancellationReason? // Reason for cancellation if cancelled
  cancelledAt         DateTime?
  // Audit fields - store as simple strings or IDs for reporting
  cancelledByMemberId String?             @db.ObjectId // ID of member who cancelled (for analytics)

  // Walk-in appointment fields (used when clientId is null)
  walkInClientName  String? // Temporary name for walk-in client (e.g., "Walk-in #123")
  walkInClientPhone String? // Optional phone for walk-in client

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  client            Client? @relation(fields: [clientId], references: [id], onDelete: Cascade) // Optional for walk-ins
  member            Member  @relation("AssignedAppointments", fields: [memberId], references: [id], onDelete: Cascade) // Service provider
  bookedByMember    Member  @relation("BookedAppointments", fields: [bookedByMemberId], references: [id], onDelete: Cascade) // Member who booked
  cancelledByMember Member? @relation("CancelledAppointments", fields: [cancelledByMemberId], references: [id], onDelete: SetNull) // Member who cancelled
  service           Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([clientId])
  @@index([memberId])
  @@index([serviceId])
  @@index([startTime])
  @@index([status])
}

model Shift {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  memberId String @db.ObjectId
  orgId    String

  // Shift timing
  date      DateTime // The date of the shift (YYYY-MM-DD)
  startTime String // Start time in HH:MM format (e.g., "09:00")
  endTime   String // End time in HH:MM format (e.g., "17:00")
  duration  Float // Duration in hours (calculated from start/end time)

  // Shift details
  title       String? // Optional title for the shift
  description String? // Optional description
  color       String? // Hex color for calendar display (e.g., "#3B82F6")

  // Shift status
  status ShiftStatus @default(SCHEDULED)

  // Break information
  breaks Json? // Array of break periods: [{ startTime: "12:00", endTime: "13:00", title: "Lunch" }]

  // Recurring shift information
  isRecurring       Boolean            @default(false)
  recurrencePattern RecurrencePattern?
  parentShiftId     String?            @db.ObjectId // Reference to parent recurring shift

  // Metadata
  createdBy String   @db.ObjectId // Member who created the shift
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  member          Member @relation("AssignedShifts", fields: [memberId], references: [id], onDelete: Cascade)
  createdByMember Member @relation("CreatedShifts", fields: [createdBy], references: [id])

  @@unique([memberId, date, startTime]) // Prevent overlapping shifts
  @@index([orgId])
  @@index([memberId])
  @@index([date])
  @@index([status])
}
